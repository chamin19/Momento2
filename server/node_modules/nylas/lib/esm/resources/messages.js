import { Blob, FormData } from 'formdata-node';
import { attachmentStreamToFile, calculateTotalPayloadSize, encodeAttachmentContent, makePathParams, objKeysToSnakeCase, } from '../utils.js';
import { Resource } from './resource.js';
import { SmartCompose } from './smartCompose.js';
/**
 * Nylas Messages API
 *
 * The Nylas Messages API allows you to list, find, update, delete, schedule, and send messages on user accounts.
 */
export class Messages extends Resource {
    constructor(apiClient) {
        super(apiClient);
        this.smartCompose = new SmartCompose(apiClient);
    }
    /**
     * Return all Messages
     * @return A list of messages
     */
    list({ identifier, queryParams, overrides, }) {
        const modifiedQueryParams = queryParams
            ? { ...queryParams }
            : undefined;
        // Transform some query params that are arrays into comma-delimited strings
        if (modifiedQueryParams && queryParams) {
            if (Array.isArray(queryParams?.anyEmail)) {
                delete modifiedQueryParams.anyEmail;
                modifiedQueryParams['any_email'] = queryParams.anyEmail.join(',');
            }
        }
        return super._list({
            queryParams: modifiedQueryParams,
            overrides,
            path: makePathParams('/v3/grants/{identifier}/messages', { identifier }),
        });
    }
    /**
     * Return a Message
     * @return The message
     */
    find({ identifier, messageId, overrides, queryParams, }) {
        return super._find({
            path: makePathParams('/v3/grants/{identifier}/messages/{messageId}', {
                identifier,
                messageId,
            }),
            overrides,
            queryParams,
        });
    }
    /**
     * Update a Message
     * @return The updated message
     */
    update({ identifier, messageId, requestBody, overrides, }) {
        return super._update({
            path: makePathParams('/v3/grants/{identifier}/messages/{messageId}', {
                identifier,
                messageId,
            }),
            requestBody,
            overrides,
        });
    }
    /**
     * Delete a Message
     * @return The deleted message
     */
    destroy({ identifier, messageId, overrides, }) {
        return super._destroy({
            path: makePathParams('/v3/grants/{identifier}/messages/{messageId}', {
                identifier,
                messageId,
            }),
            overrides,
        });
    }
    /**
     * Send an email
     * @return The sent message
     */
    async send({ identifier, requestBody, overrides, }) {
        const path = makePathParams('/v3/grants/{identifier}/messages/send', {
            identifier,
        });
        const requestOptions = {
            method: 'POST',
            path,
            overrides,
        };
        // Use form data if the total payload size (body + attachments) is greater than 3mb
        const totalPayloadSize = calculateTotalPayloadSize(requestBody);
        if (totalPayloadSize >= Messages.MAXIMUM_JSON_ATTACHMENT_SIZE) {
            requestOptions.form = Messages._buildFormRequest(requestBody);
        }
        else {
            if (requestBody.attachments) {
                const processedAttachments = await encodeAttachmentContent(requestBody.attachments);
                requestOptions.body = {
                    ...requestBody,
                    attachments: processedAttachments,
                };
            }
            else {
                requestOptions.body = requestBody;
            }
        }
        return this.apiClient.request(requestOptions);
    }
    /**
     * Retrieve your scheduled messages
     * @return A list of scheduled messages
     */
    listScheduledMessages({ identifier, overrides, }) {
        return super._find({
            path: makePathParams('/v3/grants/{identifier}/messages/schedules', {
                identifier,
            }),
            overrides,
        });
    }
    /**
     * Retrieve a scheduled message
     * @return The scheduled message
     */
    findScheduledMessage({ identifier, scheduleId, overrides, }) {
        return super._find({
            path: makePathParams('/v3/grants/{identifier}/messages/schedules/{scheduleId}', { identifier, scheduleId }),
            overrides,
        });
    }
    /**
     * Stop a scheduled message
     * @return The confirmation of the stopped scheduled message
     */
    stopScheduledMessage({ identifier, scheduleId, overrides, }) {
        return super._destroy({
            path: makePathParams('/v3/grants/{identifier}/messages/schedules/{scheduleId}', { identifier, scheduleId }),
            overrides,
        });
    }
    /**
     * Remove extra information from a list of messages
     * @return The list of cleaned messages
     */
    cleanMessages({ identifier, requestBody, overrides, }) {
        return this.apiClient.request({
            method: 'PUT',
            path: makePathParams('/v3/grants/{identifier}/messages/clean', {
                identifier,
            }),
            body: requestBody,
            overrides,
        });
    }
    static _buildFormRequest(requestBody) {
        const form = new FormData();
        // Split out the message payload from the attachments
        const messagePayload = {
            ...requestBody,
            attachments: undefined,
        };
        form.append('message', JSON.stringify(objKeysToSnakeCase(messagePayload)));
        // Add a separate form field for each attachment
        if (requestBody.attachments && requestBody.attachments.length > 0) {
            requestBody.attachments.map((attachment, index) => {
                const contentId = attachment.contentId || `file${index}`;
                // Handle different content types for formdata-node
                if (typeof attachment.content === 'string') {
                    // Base64 string - create a Blob
                    const buffer = Buffer.from(attachment.content, 'base64');
                    const blob = new Blob([buffer], { type: attachment.contentType });
                    form.append(contentId, blob, attachment.filename);
                }
                else if (Buffer.isBuffer(attachment.content)) {
                    // Buffer - create a Blob
                    const blob = new Blob([attachment.content], {
                        type: attachment.contentType,
                    });
                    form.append(contentId, blob, attachment.filename);
                }
                else {
                    // ReadableStream - create a proper file-like object according to formdata-node docs
                    const file = attachmentStreamToFile(attachment);
                    form.append(contentId, file, attachment.filename);
                }
            });
        }
        return form;
    }
}
// The maximum size of an attachment that can be sent using json
Messages.MAXIMUM_JSON_ATTACHMENT_SIZE = 3 * 1024 * 1024;
