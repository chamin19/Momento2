import { CreateAttachmentRequest } from './models/attachments.js';
export declare function createFileRequestBuilder(filePath: string): CreateAttachmentRequest;
/**
 * Converts a ReadableStream to a base64 encoded string.
 * @param stream The ReadableStream containing the binary data.
 * @returns The stream base64 encoded to a string.
 */
export declare function streamToBase64(stream: NodeJS.ReadableStream): Promise<string>;
/**
 * Converts a ReadableStream to a File-like object that can be used with FormData.
 * @param attachment The attachment containing the stream and metadata.
 * @param mimeType The MIME type for the file (optional).
 * @returns A File-like object that properly handles the stream.
 */
export declare function attachmentStreamToFile(attachment: CreateAttachmentRequest, mimeType?: string): any;
/**
 * Encodes the content of each attachment to base64.
 * Handles ReadableStream, Buffer, and string content types.
 * @param attachments The attachments to encode.
 * @returns The attachments with their content encoded to base64.
 */
export declare function encodeAttachmentContent(attachments: CreateAttachmentRequest[]): Promise<CreateAttachmentRequest[]>;
/**
 * @deprecated Use encodeAttachmentContent instead. This alias is provided for backwards compatibility.
 * Encodes the content of each attachment stream to base64.
 * @param attachments The attachments to encode.
 * @returns The attachments with their content encoded to base64.
 */
export declare function encodeAttachmentStreams(attachments: CreateAttachmentRequest[]): Promise<CreateAttachmentRequest[]>;
/**
 * A utility function that recursively converts all keys in an object to camelCase.
 * @param obj The object to convert
 * @param exclude An array of keys to exclude from conversion
 * @returns The converted object
 * @ignore Not for public use.
 */
export declare function objKeysToCamelCase(obj: Record<string, unknown>, exclude?: string[]): any;
/**
 * A utility function that recursively converts all keys in an object to snake_case.
 * @param obj The object to convert
 * @param exclude An array of keys to exclude from conversion
 * @returns The converted object
 */
export declare function objKeysToSnakeCase(obj: Record<string, unknown>, exclude?: string[]): any;
/**
 * A better "Partial" type that makes all properties optional, including nested ones.
 * @see https://grrr.tech/posts/2021/typescript-partial/
 */
export type Subset<K> = {
    [attr in keyof K]?: K[attr] extends object ? Subset<K[attr]> : K[attr] extends object | null ? Subset<K[attr]> | null : K[attr] extends object | null | undefined ? Subset<K[attr]> | null | undefined : K[attr];
};
/**
 * Safely encodes a path template with replacements.
 * @param pathTemplate The path template to encode.
 * @param replacements The replacements to encode.
 * @returns The encoded path.
 */
export declare function safePath(pathTemplate: string, replacements: Record<string, string>): string;
export type ExtractPathParams<S extends string> = S extends `${string}{${infer Param}}${infer Rest}` ? Param | ExtractPathParams<Rest> : never;
export interface PathParams<Path extends string> {
    path: Path;
    params: Record<ExtractPathParams<Path>, string>;
    toString(): string;
    toPath(): string;
}
export declare function makePathParams<Path extends string>(path: Path, params: Record<ExtractPathParams<Path>, string>): string;
/**
 * Calculates the total payload size for a message request, including body and attachments.
 * This is used to determine if multipart/form-data should be used instead of JSON.
 * @param requestBody The message request body
 * @returns The total estimated payload size in bytes
 */
export declare function calculateTotalPayloadSize(requestBody: any): number;
